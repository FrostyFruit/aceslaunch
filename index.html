<!DOCTYPE html>
<html>
<head>
    <title>Floating Logos Landing Page</title>
    <style>
        @font-face {
            font-family: 'Spray Letter';
            src: url('https://aces.fun/fonts/SprayLetters.otf') format('opentype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }
        
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: white;
            font-family: 'YourFontName', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }
        .header {
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 10px;
        }
        h1 {
            font-size: 4rem;
            margin-bottom: 1rem;
            color: #333;
        }
        h1 span {
            font-family: 'Spray Letter', sans-serif;
        }
        .slogan {
            font-family: 'Spray Letter', sans-serif;
            font-size: 1.8rem;
            color: #666;
        }
        .logo {
            position: absolute;
            opacity: 0.9;
            transition: transform 0.3s ease-out;
            will-change: transform;
            transition: transform 0.05s linear;
        }
        .container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div class="container"></div>
    <div class="header">
        <h1>Aces.<span>Fun</span></h1>
        <p class="slogan">AI Token Launchpad for RWAs</p>
    </div>

    <script>
        class FloatingLogo {
            constructor(type, baseX, baseY, size) {
                this.exitDirection = Math.floor(Math.random() * 4); // 0: top, 1: right, 2: bottom, 3: left
                this.element = document.createElement('img');
                this.element.className = 'logo';
                this.element.src = type === 1 ? 'https://aces.fun/images/ACES-logo-01.png' : 'https://aces.fun/images/ACES-logo-02.png';
                this.element.alt = 'Logo';
                
                // Size and position
                this.size = size;
                this.element.style.width = `${size}px`;
                this.element.style.height = `${size}px`;
                this.baseX = baseX;
                this.baseY = baseY;
                this.x = baseX;
                this.y = -100; // Start above viewport
                
                // Movement properties
                this.offsetX = 0;
                this.offsetY = 0;
                this.maxOffset = size * 0.5; // Increased movement range relative to size
                
                // Animation properties
                this.angle = Math.random() * Math.PI * 2;
                this.angleSpeed = 0.001 + (Math.random() * 0.002); // Increased movement speed
                this.amplitude = this.maxOffset * 0.5;
                
                // Entry animation
                this.entering = true;
                this.entranceProgress = 0;
                this.entranceDelay = Math.random() * 1000; // Stagger entrance
                this.entranceStartTime = Date.now() + this.entranceDelay;
                
                document.querySelector('.container').appendChild(this.element);
            }

            update(mouseX, mouseY, time) {
                if (this.entering) {
                    if (time < this.entranceStartTime) return;
                    
                    this.entranceProgress += 0.01;
                    if (this.entranceProgress >= 1) {
                        this.entering = false;
                    }
                    
                    const progress = easeOutCubic(this.entranceProgress);
                    this.y = lerp(-100, this.baseY, progress);
                    this.x = this.baseX;
                } else {
                    // Subtle autonomous movement
                    this.angle += this.angleSpeed;
                    
                    // Calculate base movement
                    this.offsetX = Math.cos(this.angle) * this.amplitude;
                    this.offsetY = Math.sin(this.angle) * this.amplitude;
                    
                    // Mouse influence
                    const dx = mouseX - (this.baseX + this.size/2);
                    const dy = mouseY - (this.baseY + this.size/2);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const maxDistance = 300;
                    
                    if (distance < maxDistance) {
                        const factor = (1 - distance / maxDistance) * 0.15;
                        this.offsetX += dx * factor;
                        this.offsetY += dy * factor;
                        
                        // Limit maximum offset
                        const currentOffset = Math.sqrt(this.offsetX * this.offsetX + this.offsetY * this.offsetY);
                        if (currentOffset > this.maxOffset) {
                            const scale = this.maxOffset / currentOffset;
                            this.offsetX *= scale;
                            this.offsetY *= scale;
                        }
                    }
                    
                    // Update position
                    this.x = this.baseX + this.offsetX;
                    this.y = this.baseY + this.offsetY;
                }

                // Apply position
                // For regular updates, maintain the normal transform
                this.element.style.transform = `translate(${this.x}px, ${this.y}px)`;
            }

            exit() {
                this.entering = false;
                const centerX = window.innerWidth / 2;
                const speed = 15;
                
                // Move towards center as they fall
                const distanceFromCenter = this.x - centerX;
                const pullToCenter = distanceFromCenter * 0.1;
                
                // Accelerating downward movement
                this.y += speed + (window.innerHeight - this.y) * 0.05;
                
                // Pull towards center more as they fall
                const fallProgress = this.y / window.innerHeight;
                this.x -= pullToCenter * fallProgress;
                
                // Add slight rotation based on position
                const rotation = (distanceFromCenter / centerX) * 45 * fallProgress;
                this.element.style.transform = `translate(${this.x}px, ${this.y}px) rotate(${rotation}deg)`;
                
                return this.y > window.innerHeight + 100;
            }
        }

        // Utility functions
        function lerp(start, end, t) {
            return start * (1 - t) + end * t;
        }

        function easeOutCubic(x) {
            return 1 - Math.pow(1 - x, 3);
        }

        function distance(x1, y1, x2, y2) {
            return Math.sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1));
        }

        // Track mouse position
        let mouseX = window.innerWidth / 2;
        let mouseY = window.innerHeight / 2;
        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        function createWebLayout() {
            const container = document.querySelector('.container');
            const logos = [];
            const headerHeight = window.innerHeight * 0.4;
            const positions = [];
                            const minDistance = 85; // Adjusted spacing for more logos
            
            // Create position finding function
            function findValidPosition(size) {
                let attempts = 0;
                const maxAttempts = 100;
                
                while (attempts < maxAttempts) {
                    // Generate position with more weight towards the center but with variation
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * Math.min(window.innerWidth, window.innerHeight) * 0.6;
                    
                    const x = window.innerWidth/2 + Math.cos(angle) * radius + (Math.random() - 0.5) * 200;
                    const y = window.innerHeight/2 + Math.sin(angle) * radius + (Math.random() - 0.5) * 200;
                    
                    // Check if position is valid
                    if (y < headerHeight + size || y > window.innerHeight - size || 
                        x < size || x > window.innerWidth - size) {
                        attempts++;
                        continue;
                    }
                    
                    // Check distance from other logos
                    let valid = true;
                    for (const pos of positions) {
                        if (distance(x, y, pos.x, pos.y) < minDistance + (size + pos.size)/2) {
                            valid = false;
                            break;
                        }
                    }
                    
                    if (valid) {
                        return {x, y};
                    }
                    
                    attempts++;
                }
                return null;
            }
            
            // Create logos with varying sizes
            const numLogos = 120; // Further increased number of logos
            for (let i = 0; i < numLogos; i++) {
                const size = 50 + Math.random() * 40; // Vary size between 50 and 90 pixels
                const position = findValidPosition(size);
                
                if (position) {
                    positions.push({...position, size});
                    logos.push(new FloatingLogo(
                        i % 2,
                        position.x,
                        position.y,
                        size
                    ));
                }
            }
            
            return logos;
        }

        // Create layout
        let logos = createWebLayout();
        let newLogos = [];
        let isExiting = false;
        let lastRefreshTime = Date.now();
        const refreshInterval = 9000; // 9 seconds

        // Animation loop
        function animate() {
            const currentTime = Date.now();
            const timeSinceRefresh = currentTime - lastRefreshTime;

            if (timeSinceRefresh >= refreshInterval && !isExiting) {
                isExiting = true;
                newLogos = createWebLayout(); // Create new logos immediately
                setTimeout(() => {
                    logos = logos.filter(logo => {
                        if (logo.y > window.innerHeight + 100) {
                            logo.element.remove();
                            return false;
                        }
                        return true;
                    });
                    isExiting = false;
                    lastRefreshTime = Date.now();
                }, 2000); // Longer cleanup time for smoother transition
            }

            if (isExiting) {
                // Update exit animations for old logos
                logos.forEach(logo => logo.exit());
                // Update entrance animations for new logos
                newLogos.forEach(logo => logo.update(mouseX, mouseY, currentTime));
            } else {
                // Normal update for current set
                logos.forEach(logo => logo.update(mouseX, mouseY, currentTime));
            }

            requestAnimationFrame(animate);
        }

        animate();

        // Handle window resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                document.querySelector('.container').innerHTML = '';
                logos = createWebLayout();
            }, 250);
        });
    </script>
</body>
</html>
