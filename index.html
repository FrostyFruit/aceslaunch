<!DOCTYPE html>
<html>
<head>
    <title>Aces.fun Landing Page</title>
    <style>
        @font-face {
            font-family: 'Spray Letter';
            src: url('https://aces.fun/fonts/SprayLetters.otf') format('opentype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }
        
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: white;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }
        .header {
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 10px;
        }
        h1 {
            font-size: 4rem;
            margin-bottom: 1rem;
            color: #333;
        }
        h1 span {
            font-family: 'Spray Letter', sans-serif;
        }
        .slogan {
            font-family: 'Spray Letter', sans-serif;
            font-size: 1.8rem;
            color: #666;
        }
        .logo {
            position: absolute;
            opacity: 0;
            transition: opacity 0.5s ease-out;
            will-change: transform;
        }
        .container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div class="container"></div>
    <div class="header">
        <h1>Aces.<span>Fun</span></h1>
        <p class="slogan">AI Token Launchpad for RWAs</p>
    </div>

    <script>
        class FloatingLogo {
            constructor(type, baseX, baseY, size) {
                this.element = document.createElement('img');
                this.element.className = 'logo';
                this.element.src = type === 1 ? 'https://aces.fun/images/ACES-logo-01.png' : 'https://aces.fun/images/ACES-logo-02.png';
                this.element.alt = 'Logo';
                
                // Size and position
                this.size = size;
                this.element.style.width = `${size}px`;
                this.element.style.height = `${size}px`;
                this.baseX = baseX;
                this.baseY = baseY;
                this.x = baseX;
                this.y = -100;
                
                // Movement properties
                this.offsetX = 0;
                this.offsetY = 0;
                this.maxOffset = size * 0.5;
                
                // Animation properties
                this.angle = Math.random() * Math.PI * 2;
                this.angleSpeed = 0.001 + (Math.random() * 0.002);
                this.amplitude = this.maxOffset * 0.5;
                
                // Entry animation
                this.entering = true;
                this.entranceProgress = 0;
                this.startY = -200 - (Math.random() * 300); // Random starting heights above viewport
                this.y = this.startY;
                this.element.style.opacity = '0.9'; // Start visible for entrance animation
                
                document.querySelector('.container').appendChild(this.element);
            }

            update(mouseX, mouseY, time) {
                if (this.entering) {
                    // Faster entrance animation
                    this.entranceProgress += 0.02;
                    if (this.entranceProgress >= 1) {
                        this.entering = false;
                    }
                    
                    // Smooth fall from starting position
                    const progress = easeOutCubic(this.entranceProgress);
                    this.y = lerp(this.startY, this.baseY, progress);
                    this.x = lerp(this.x, this.baseX, progress);
                } else {
                    this.angle += this.angleSpeed;
                    
                    this.offsetX = Math.cos(this.angle) * this.amplitude;
                    this.offsetY = Math.sin(this.angle) * this.amplitude;
                    
                    const dx = mouseX - (this.baseX + this.size/2);
                    const dy = mouseY - (this.baseY + this.size/2);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const maxDistance = 300;
                    
                    if (distance < maxDistance) {
                        const factor = (1 - distance / maxDistance) * 0.15;
                        this.offsetX += dx * factor;
                        this.offsetY += dy * factor;
                        
                        const currentOffset = Math.sqrt(this.offsetX * this.offsetX + this.offsetY * this.offsetY);
                        if (currentOffset > this.maxOffset) {
                            const scale = this.maxOffset / currentOffset;
                            this.offsetX *= scale;
                            this.offsetY *= scale;
                        }
                    }
                    
                    this.x = this.baseX + this.offsetX;
                    this.y = this.baseY + this.offsetY;
                }

                this.element.style.transform = `translate(${this.x}px, ${this.y}px)`;
            }

            exit() {
                this.entering = false;
                const centerX = window.innerWidth / 2;
                const speed = 20; // Increased exit speed
                
                // Stronger center pull
                const distanceFromCenter = this.x - centerX;
                const pullToCenter = distanceFromCenter * 0.15;
                
                // Accelerating fall
                this.y += speed + (window.innerHeight - this.y) * 0.08;
                
                // Stronger pull towards center as they fall
                const fallProgress = this.y / window.innerHeight;
                this.x -= pullToCenter * fallProgress;
                
                // More pronounced rotation
                const rotation = (distanceFromCenter / centerX) * 90 * fallProgress;
                this.element.style.transform = `translate(${this.x}px, ${this.y}px) rotate(${rotation}deg)`;
                
                return this.y > window.innerHeight + 100;
            }
        }

        // Utility functions
        function lerp(start, end, t) {
            return start * (1 - t) + end * t;
        }

        function easeOutCubic(x) {
            return 1 - Math.pow(1 - x, 3);
        }

        function distance(x1, y1, x2, y2) {
            return Math.sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1));
        }

        let mouseX = window.innerWidth / 2;
        let mouseY = window.innerHeight / 2;
        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        function createWebLayout() {
            const container = document.querySelector('.container');
            const logos = [];
            const headerHeight = window.innerHeight * 0.4;
            const positions = [];
            const minDistance = 85;
            
            function findValidPosition(size) {
                let attempts = 0;
                const maxAttempts = 100;
                
                while (attempts < maxAttempts) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * Math.min(window.innerWidth, window.innerHeight) * 0.6;
                    
                    const x = window.innerWidth/2 + Math.cos(angle) * radius + (Math.random() - 0.5) * 200;
                    const y = window.innerHeight/2 + Math.sin(angle) * radius + (Math.random() - 0.5) * 200;
                    
                    if (y < headerHeight + size || y > window.innerHeight - size || 
                        x < size || x > window.innerWidth - size) {
                        attempts++;
                        continue;
                    }
                    
                    let valid = true;
                    for (const pos of positions) {
                        if (distance(x, y, pos.x, pos.y) < minDistance + (size + pos.size)/2) {
                            valid = false;
                            break;
                        }
                    }
                    
                    if (valid) {
                        return {x, y};
                    }
                    
                    attempts++;
                }
                return null;
            }
            
            const numLogos = 120;
            for (let i = 0; i < numLogos; i++) {
                const size = 50 + Math.random() * 40;
                const position = findValidPosition(size);
                
                if (position) {
                    positions.push({...position, size});
                    logos.push(new FloatingLogo(
                        i % 2,
                        position.x,
                        position.y,
                        size
                    ));
                }
            }
            
            return logos;
        }

        // Create initial layout
        let logos = createWebLayout();
        let isExiting = false;
        let lastRefreshTime = Date.now();
        const refreshInterval = 9000; // 9 seconds
        
        function refreshLogos() {
            isExiting = true;
            const oldLogos = logos;
            logos = createWebLayout(); // Create new set
            
            setTimeout(() => {
                // Remove old logos
                oldLogos.forEach(logo => logo.element.remove());
                isExiting = false;
                lastRefreshTime = Date.now();
            }, 2000);
        }

        // Animation loop
        function animate() {
            const currentTime = Date.now();
            const timeSinceRefresh = currentTime - lastRefreshTime;

            if (timeSinceRefresh >= refreshInterval && !isExiting) {
                refreshLogos();
            }

            if (isExiting) {
                // Update exit animations for current logos
                logos.forEach(logo => logo.exit());
            } else {
                // Normal update for current set
                logos.forEach(logo => logo.update(mouseX, mouseY, currentTime));
            }

            requestAnimationFrame(animate);
        }

        animate();

        // Initial refresh cycle
        setInterval(refreshLogos, refreshInterval);
    </script>
</body>
</html>
